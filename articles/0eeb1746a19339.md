---
title: "メッシュコードで位置情報検索を効率化する"
emoji: "🦀"
type: "tech"
topics: [ "rust", "meshcode", "gis", "位置情報", ]
published: false
---

## はじめに

求人検索、飲食店検索、賃貸物件検索など、位置情報を扱うサービスを開発していると「近くの〇〇を探す」という機能の実装に頭を悩ませることがあります。

緯度経度だけで検索すると、以下のような課題に直面します。

- データベースの複合インデックスが効率的に使えず検索が遅い
- 距離計算（Haversine式）に三角関数が必要でCPU負荷が高い
- 「駅周辺」「エリア内」といった曖昧な範囲検索の実装が複雑

これらの課題を解決する手段として、**メッシュコード**の活用があります。

本記事では、メッシュコードの基礎から、求人・飲食・賃貸サービスでの具体的な活用方法、Rustでの実装例（[jismeshcode](https://crates.io/crates/jismeshcode)ライブラリ）までを紹介します。

## メッシュコードとは？

### 日本標準地域メッシュコード（JIS X 0410）の基礎

メッシュコードは、日本の国土を格子状に分割して、各エリアに固有のコードを付与したものです。統計目的で政府が標準化しており（JIS X 0410）、国勢調査や経済センサスなどの公的統計データでも使用されています。

地図を碁盤の目のように分割し、それぞれのマス（メッシュ）に番号を振ることで、緯度経度の「点」ではなく「エリア」として位置情報を扱えるのが特徴です。

### メッシュの階層構造

メッシュコードは階層構造になっており、用途に応じて精度を選べます。

| レベル | サイズ | 桁数 | 用途例 |
|--------|--------|------|--------|
| 1次メッシュ | 約80km四方 | 4桁 | 都道府県レベルの広域分析 |
| 2次メッシュ | 約10km四方 | 6桁 | 市区町村レベルの分析 |
| 3次メッシュ | 約1km四方 | 8桁 | 町丁目レベルの分析 |
| 4次メッシュ（2分の1） | 約500m四方 | 9桁 | より詳細な分析 |
| 5次メッシュ | 約100m四方 | 10桁 | 建物レベルの分析 |

例えば、東京駅の3次メッシュコードは `53394611` です。

```
5339      ← 1次メッシュ（約80km四方）
533946    ← 2次メッシュ（約10km四方）
53394611  ← 3次メッシュ（約1km四方）
```

階層の上位桁が共通しているメッシュは地理的に近い位置にあります。このため、プレフィックスマッチングで広域検索が可能です。

### 緯度経度との違い

| 特徴 | 緯度経度 | メッシュコード |
|------|----------|---------------|
| データ型 | 連続値（実数） | 離散値（整数・文字列） |
| 表現する対象 | 点 | エリア |
| 検索方法 | 範囲検索（BETWEEN） | 等価検索（IN, =） |
| インデックス | 複合インデックス必要 | 単一カラムで可 |

## 求人・飲食・賃貸サービスでメッシュコードを使う利点

### データベースインデックスの効率化

これがメッシュコードを使う最大のメリットです。

#### 緯度経度の複合インデックスの限界

緯度経度で `INDEX(lat, lon)` のような複合インデックスを貼っても、2次元の範囲検索では効率が悪くなります。

```sql
-- 緯度経度での範囲検索（遅い）
SELECT * FROM locations
WHERE lat BETWEEN 35.6 AND 35.7
  AND lon BETWEEN 139.7 AND 139.8;
```

B-Treeインデックスは1次元データに最適化されており、2次元の範囲検索では片方の条件しか活用されません。実行計画を見ると、`lat`の範囲は絞れますが、`lon`は毎回フィルタリングが必要になります。

**技術的な詳細:**

```
INDEX(lat, lon) の実行計画：

1. lat BETWEEN条件でインデックスをシーク
2. シーク後、各行でlon条件をチェック（フィルタ）
3. インデックスの効率: 約30-50%

具体例（100万行のテーブル）:
- lat範囲に50万行が該当
- その50万行すべてをlon条件でフィルタ
- 実際に必要な5,000行に絞られるまで全行チェック

メッシュコードの場合:
- 9個のメッシュコードのみをインデックスシーク
- 該当5,000行をダイレクト取得（フィルタなし）
```

#### メッシュコードのインデックスの優位性

メッシュコードなら、単一カラム `INDEX(mesh_code_3rd)` での等価検索またはIN検索が可能です。

```sql
-- メッシュコードでの検索（速い）
SELECT * FROM locations
WHERE mesh_code_3rd IN (
  '53394611', '53394612', '53394621',
  '53394622', '53394631', '53394632',
  '53394701', '53394702', '53394711'
);
```

B-Treeインデックスが最大限に活用され、直接該当レコードへアクセスできます。フィルタリングも不要です。

#### メッシュコード分散の現実

3次メッシュ（約1km四方）での分布は、場所により大きく異なります：

**都市部中心（渋谷・新宿など）:**
- 1メッシュあたり: 800-2,000件
- 隣接9メッシュ合計: 12,000-18,000件
- 対策: ページネーション必須、さらに条件で絞り込み

**郊外エリア:**
- 1メッシュあたり: 50-200件
- 隣接9メッシュ合計: 500-1,800件
- 対策: 標準的な実装で対応可能

**過疎地域:**
- 1メッシュあたり: 0-10件
- 隣接9メッシュ合計: 0-50件
- 対策: より広い範囲（2次メッシュ）で検索

検索範囲は固定ではなく、都市化度と検索条件に応じて動的に調整する必要があります。

#### 従来の距離計算パターンの問題点

Haversine式を使った距離計算は、全レコードで三角関数を計算する必要があります。

```sql
-- Haversine式による距離計算（非常に遅い）
SELECT
  *,
  (6371 * acos(
    cos(radians(35.6812)) * cos(radians(lat)) *
    cos(radians(lon) - radians(139.7671)) +
    sin(radians(35.6812)) * sin(radians(lat))
  )) AS distance_km
FROM locations
WHERE
  lat BETWEEN 35.6712 AND 35.6912
  AND lon BETWEEN 139.7571 AND 139.7771
HAVING distance_km < 1.0
ORDER BY distance_km
LIMIT 100;
```

**問題点:**
- すべてのレコードで三角関数（sin, cos, acos）を計算（CPUコストが高い）
- HAVINGは計算後のフィルタリングなのでインデックスが使えない
- ORDER BYでソートするには全件の距離計算が必要


#### メッシュコードでの周辺検索パターン

メッシュコードを使えば、アプリケーション側で周辺メッシュを事前計算し、データベース側は単純なインデックス検索のみで済みます。

```rust
// アプリケーション側で周辺メッシュを事前計算（v0.2以降）
let nearby_meshes: Vec<_> = mesh_codes_in_radius_from_mesh(
    coord_to_mesh(coord, MeshLevel::Third).unwrap(),
    1000.0
).collect();
```

```sql
-- シンプルなIN検索（高速）
SELECT * FROM locations
WHERE mesh_code_3rd IN (
  '53394611', '53394612', '53394621',
  '53394622', '53394631', '53394632',
  '53394701', '53394702', '53394711'
)
LIMIT 100;
```

**利点:**
- データベース側は単純なインデックス検索のみ（CPU負荷が低い）
- 三角関数の計算が不要
- INDEXが最大限に活用される
- アプリケーション側で検索範囲を柔軟にコントロール可能

#### 空間インデックスとの比較

PostgreSQL + PostGISのGiSTインデックスやMySQL 8.0+の空間インデックスを使えば、より高度な空間検索が可能です。

**空間インデックスの特徴:**
- PostgreSQL: PostGIS拡張のインストールが必要（GiST/SP-GiSTインデックス）
- MySQL 8.0+: 標準で空間インデックスをサポート
- 高度な空間クエリ（ポリゴン内検索、バッファ検索など）に対応

**メッシュコードの特徴:**
- 拡張機能不要で標準的なRDBMS（MySQL 5.x、PostgreSQL、SQLite）でも使える
- 標準的なB-Treeインデックスのみで高速検索が可能
- 実装がシンプルで保守しやすい
- 政府統計データ（国勢調査など）と直接連携できる

PostGISなどの空間データベース拡張を使える環境なら、それらも有力な選択肢です。メッシュコードは、拡張機能が使えない環境や、統計データとの連携が必要な場合に特に有効です。

### IN句の制限と実装パターン

メッシュコード検索でIN句を使う際の制約：

**データベース別の制限:**
- MySQL: max_allowed_packet（デフォルト4MB）で制限、実務では1000個程度が安全
- PostgreSQL: 理論的制限なしだが、1000個以上ではプラナー効率低下
- SQLite: 制限なし

**推奨パターン:**

広範囲検索が必要な場合は、階層的な絞り込みを組み合わせます。

```sql
-- 2次メッシュで広域絞り込み（50個程度）
SELECT * FROM jobs
WHERE mesh_code_2nd IN ('533946', '533947', '533956', ...)
-- その上で3次メッシュで詳細化（9個程度）
  AND mesh_code_3rd IN ('53394611', '53394612', ...);
```

プレフィックスマッチングとの併用も有効です。

```sql
-- 2次メッシュ範囲内で3次メッシュのIN検索
SELECT * FROM jobs
WHERE mesh_code_3rd LIKE '533946%'
  AND mesh_code_3rd IN ('53394611', '53394612', ...);
```

### エリア検索の高速化

プレフィックスマッチングで大まかなエリア判定ができます。

```sql
-- 2次メッシュ533946で始まる = 約10km圏内
SELECT * FROM locations
WHERE mesh_code_3rd LIKE '533946%';
```

階層的な検索（広域→詳細）も容易です。

### 曖昧な範囲検索への対応

「駅周辺」「エリア内」といった実装が容易になります。ユーザーが地図上で選択した範囲をメッシュに変換すれば、境界が明確で判定ロジックもシンプルです。


### データの集計・分析

エリアごとの集計が容易で、BI/分析ツールとの親和性が高いです。

```sql
-- エリアごとの物件数を集計
SELECT mesh_code_3rd, COUNT(*) as property_count
FROM properties
GROUP BY mesh_code_3rd;
```

ヒートマップ生成も簡単です。

## jismeshcodeライブラリの紹介

[jismeshcode](https://crates.io/crates/jismeshcode)は、Rustで日本標準地域メッシュコードを扱うための包括的なライブラリです。

### 特徴

- **高性能**: ゼロコスト抽象化と最適化されたアルゴリズム
- **完全なJIS X 0410対応**: 1次〜5次メッシュまで完全サポート
- **使いやすいAPI**: 型安全で直感的な設計
- **豊富な機能**: 座標変換、隣接メッシュ、空間範囲検索など

### インストール方法

`Cargo.toml`に以下を追加します。

```toml
[dependencies]
jismeshcode = "0.2"
```

## 実装例：サービス別のユースケース

### 基本的な使い方

まずは座標からメッシュコードへの変換とメッシュ情報の取得を見ていきます。

```rust
use jismeshcode::prelude::*;

fn main() {
    // 東京駅の座標（緯度35.6812度、経度139.7671度）
    let coord = Coordinate::new(35.6812, 139.7671).unwrap();

    // 3次メッシュ（約1km四方）に変換
    let mesh = coord_to_mesh(coord, MeshLevel::Third).unwrap();
    println!("東京駅のメッシュコード: {}", mesh); // 53394611

    // メッシュの境界を取得
    let bounds = mesh_to_bounds(mesh);
    println!(
        "南西端: ({:.6}, {:.6})",
        bounds.min_lat(),
        bounds.min_lon()
    );
    println!(
        "北東端: ({:.6}, {:.6})",
        bounds.max_lat(),
        bounds.max_lon()
    );

    // メッシュの中心座標を取得
    let center = mesh_to_center(mesh);
    println!("中心座標: ({:.6}, {:.6})", center.lat(), center.lon());
}
```

### ユースケース1: 求人検索 - エリアごとの求人一覧取得

渋谷駅周辺の求人を検索する例です。`mesh_codes_in_radius()`を使用することで、任意の距離で検索できます。通勤手段に応じて距離を調整可能です（徒歩圏500m、自転車圏2km、電車圏5km）。

```rust
use jismeshcode::prelude::*;

fn search_jobs_near_shibuya() {
    let shibuya = Coordinate::new(35.6580, 139.7016).unwrap();

    // 通勤圏2km以内の求人を検索
    let meshes: Vec<_> = mesh_codes_in_radius(shibuya, 2000.0, MeshLevel::Third)
        .collect();

    let mesh_codes: Vec<String> = meshes.iter()
        .map(|m| m.as_string())
        .collect();

    // SELECT * FROM jobs WHERE mesh_code_3rd IN (?, ...)
}
```

### ユースケース2: 飲食店検索 - 周辺店舗の探索

現在地から周辺の飲食店を検索する例です。座標から直接半径検索できるため、メッシュコードへの変換が不要です。徒歩圏内（500m）の店舗を効率的に検索できます。

```rust
use jismeshcode::prelude::*;

fn search_restaurants_nearby(user_lat: f64, user_lon: f64) {
    let location = Coordinate::new(user_lat, user_lon).unwrap();

    // 徒歩圏500m以内の飲食店を検索
    let meshes: Vec<_> = mesh_codes_in_radius(location, 500.0, MeshLevel::Third)
        .collect();

    let mesh_codes: Vec<String> = meshes.iter()
        .map(|m| m.as_string())
        .collect();

    // SELECT * FROM restaurants WHERE mesh_code_3rd IN (?, ...)
}
```

### ユースケース3: 賃貸検索 - 希望エリアの物件検索

地図上で選択した矩形範囲内の賃貸物件を検索する例です。境界ボックス（BoundingBox）を使用します。

```rust
use jismeshcode::prelude::*;

fn search_properties_in_area() {
    // 地図上で選択された矩形範囲
    let sw = Coordinate::new(35.65, 139.70).unwrap();
    let ne = Coordinate::new(35.67, 139.73).unwrap();
    let bbox = BoundingBox::new(sw, ne);

    // 範囲内の全メッシュを取得
    let meshes: Vec<_> = mesh_codes_in_bbox(bbox, MeshLevel::Third).collect();
    let mesh_codes: Vec<String> = meshes.iter()
        .map(|m| m.as_string()).collect();

    // SELECT * FROM properties WHERE mesh_code_3rd IN (?, ...)
}

// メモリ効率的な処理
fn process_large_area(bbox: BoundingBox) {
    for mesh in mesh_codes_in_bbox(bbox, MeshLevel::Third) {
        // 各メッシュごとにDB検索・処理
    }
}
```

### ユースケース4: 階層を使った段階的検索

2次メッシュで広域検索してから3次メッシュで詳細検索する例です。大量のデータを扱う場合、段階的に絞り込むことで効率が上がります。

```rust
use jismeshcode::prelude::*;

fn hierarchical_search() {
    let coord = Coordinate::new(35.6812, 139.7671).unwrap();

    // 広域検索: 2次メッシュ
    let mesh_2nd = coord_to_mesh(coord, MeshLevel::Second).unwrap();
    // SELECT COUNT(*) FROM locations WHERE mesh_code_2nd = ?

    // 詳細検索: 3次メッシュ + 周辺（1km以内）
    let mesh_3rd = coord_to_mesh(coord, MeshLevel::Third).unwrap();
    let search_meshes: Vec<_> = mesh_codes_in_radius_from_mesh(mesh_3rd, 1000.0).collect();

    // 必要に応じて2次メッシュの全子メッシュを取得
    let all_children = children(mesh_2nd);  // 100個
}
```

## 実際の開発で使う際のポイント

### データベース設計のベストプラクティス

メッシュコードを効率的に使うためのテーブル設計例です。

```sql
CREATE TABLE locations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    lat DECIMAL(10, 8) NOT NULL,
    lon DECIMAL(11, 8) NOT NULL,
    mesh_code_1st CHAR(4) NOT NULL,
    mesh_code_2nd CHAR(6) NOT NULL,
    mesh_code_3rd CHAR(8) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- インデックス
    INDEX idx_mesh_1st (mesh_code_1st),
    INDEX idx_mesh_2nd (mesh_code_2nd),
    INDEX idx_mesh_3rd (mesh_code_3rd)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**設計のポイント:**
- 各階層のメッシュコードを別カラムで保持（階層的な検索が可能）
- 各メッシュコードにインデックスを貼る
- 緯度経度も保持（詳細な距離計算や地図表示に使用）

**大規模データでのインデックス最適化:**

単純なインデックスの問題点：

```sql
INDEX idx_mesh_3rd (mesh_code_3rd)
```

この場合、ページネーション時に非効率になります。

```sql
-- 50,000行スキップが必要（遅い）
SELECT * FROM locations
WHERE mesh_code_3rd = ?
ORDER BY id
LIMIT 100 OFFSET 50000;
```

**推奨: 複合インデックス**

```sql
INDEX idx_mesh_3rd_id (mesh_code_3rd, id)
```

効果：同じメッシュ内でのID順検索が高速化します。

**さらに最適化する場合:**

```sql
INDEX idx_mesh_2nd_3rd_id (mesh_code_2nd, mesh_code_3rd, id)
```

利点：階層的検索（2次→3次）が最大限高速化します。

**インデックスサイズの見積もり:**

- 3次メッシュ: 8文字 = 約8バイト
- ID: 8バイト（BIGINT）
- 複合インデックス合計: 約16バイト/行
- 100万行の場合: 約16MB（メモリに収まりキャッシュ効率が高い）

### パフォーマンスチューニング

#### 大規模結果セットの処理戦略

検索結果の件数に応じた実装パターン：

**1. 結果が100件程度（郊外エリア）**
```sql
SELECT * FROM jobs
WHERE mesh_code_3rd IN (...)
LIMIT 100;
```

**2. 結果が1,000-5,000件（都市部郊外）**

ページネーションが必要ですが、OFFSETは避けます。

```sql
-- ❌ 非効率（OFFSETが大きいと全行スキャン）
SELECT * FROM jobs
WHERE mesh_code_3rd IN (...)
LIMIT 100 OFFSET 5000;

-- ✅ 効率的（カーソル方式）
SELECT * FROM jobs
WHERE mesh_code_3rd IN (...)
  AND id > ?  -- 前ページの最後のID
ORDER BY id
LIMIT 100;
```

**3. 結果が10,000件以上（大都市中心）**

さらに検索条件を追加して絞り込みます。

```sql
SELECT * FROM jobs
WHERE mesh_code_3rd IN (...)
  AND salary >= ?
  AND job_type IN (...)
LIMIT 100;
```

**4. 大量エクスポート（分析用途）**

バッチクエリに分割してメモリ効率を保ちます。

```rust
for mesh in all_meshes {
    let results = query_by_mesh(mesh);
    process_batch(results);  // メモリ効率的
}
```

#### バッチ変換での効率化

大量のデータを一括でメッシュコードに変換する場合、バッチ処理を活用します。

```rust
use jismeshcode::prelude::*;

fn batch_convert_to_meshcodes(locations: Vec<(f64, f64)>) -> Vec<Option<MeshCode>> {
    locations
        .into_iter()
        .map(|(lat, lon)| {
            Coordinate::new(lat, lon)
                .ok()
                .and_then(|coord| coord_to_mesh(coord, MeshLevel::Third).ok())
        })
        .collect()
}
```

#### プレフィックスマッチングの活用

広域検索には`LIKE`を使ったプレフィックスマッチングが有効です。

```sql
-- 2次メッシュ533946エリア全体（約10km圏内）
SELECT * FROM locations
WHERE mesh_code_3rd LIKE '533946%';

-- 1次メッシュ5339エリア全体（約80km圏内）
SELECT * FROM locations
WHERE mesh_code_3rd LIKE '5339%';
```

### メッシュレベルの選び方

サービスの特性に応じて適切なメッシュレベルを選択します。

| サービス | 推奨レベル | 理由 |
|---------|-----------|------|
| 求人検索 | 2次〜3次 | 通勤圏（数km〜10km程度）をカバー |
| 飲食店検索 | 3次〜4次 | 徒歩圏（数百m〜1km程度）が対象 |
| 賃貸検索 | 2次〜3次 | 駅周辺や行政区単位での検索が多い |
| コンビニ検索 | 4次〜5次 | 至近距離（数百m以内）が重要 |

検索範囲に応じて動的にレベルを変えるのも有効です。

```rust
fn select_mesh_level(radius_m: f64) -> MeshLevel {
    match radius_m {
        r if r < 200.0 => MeshLevel::Fifth,    // 100m
        r if r < 1500.0 => MeshLevel::Third,   // 1km
        r if r < 15000.0 => MeshLevel::Second, // 10km
        _ => MeshLevel::First,
    }
}
```

## まとめ

メッシュコードを活用することで、位置情報検索の以下の課題が解決できます。

1. **データベース検索の効率化**: 単一カラムのインデックスで高速検索
2. **CPU負荷の削減**: 三角関数計算が不要
3. **実装のシンプル化**: 境界が明確で判定ロジックが簡単
4. **統計データとの連携**: 政府統計と直接結合可能
5. **集計・分析の容易さ**: エリア単位の集計が自然にできる

jismeshcodeライブラリを使えば、Rustで簡単にメッシュコードを扱えます。求人・飲食・賃貸などの位置情報サービスを開発する際は、ぜひメッシュコードの活用を検討してみてください。

## 参考リンク

- [jismeshcode (crates.io)](https://crates.io/crates/jismeshcode)
- [jismeshcode GitHub](https://github.com/uiuifree/rust-jismeshcode)
- [総務省統計局 - 地域メッシュ統計](https://www.stat.go.jp/data/mesh/index.html)
- [JIS X 0410 - 地域メッシュコード](https://www.jisc.go.jp/)
